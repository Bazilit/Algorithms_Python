n = int(input())
money = list(map(int, input().strip().split()))
cost = int(input())
cost_x2 = cost * 2

def cost_bike(money, cost, left = 0, right = len(money)):
    if right <= left: # промежуток пуст
        return -1
    if money[left] >= cost:
        return left + 1
    midle = (left + right) // 2
    if money[midle-1] < cost <= money[midle]: # центральный элемент — искомый
        return midle + 1
    elif cost <= money[midle]: # искомый элемент меньше центрального
        return cost_bike(money, cost, left, midle)
    else: # иначе следует искать в правой половине
        return cost_bike(money, cost, midle + 1, right)

print(cost_bike(money, cost, left = 0, right = len(money)), cost_bike(money, cost_x2, left = 0, right = len(money)))

# Вася решил накопить денег на два одинаковых велосипеда — себе и сестре. У Васи есть копилка, в которую каждый день он может добавлять деньги (если, конечно, у него есть такая финансовая возможность). В процессе накопления Вася не вынимает деньги из копилки.
# У вас есть информация о росте Васиных накоплений — сколько у Васи в копилке было денег в каждый из дней.
# Ваша задача — по заданной стоимости велосипеда определить
# первый день, в которой Вася смог бы купить один велосипед,
# и первый день, в который Вася смог бы купить два велосипеда.
# Подсказка: решение должно работать за O(log n).

# Формат ввода
# В первой строке дано число дней n, по которым велись наблюдения за Васиными накоплениями. 1 ≤ n ≤ 106.
# В следующей строке записаны n целых неотрицательных чисел. Числа идут в порядке неубывания. Каждое из чисел не превосходит 106.
# В третьей строке записано целое положительное число s — стоимость велосипеда. Это число не превосходит 106.

# Формат вывода
# Нужно вывести два числа — номера дней по условию задачи.
# Если необходимой суммы в копилке не нашлось, нужно вернуть -1 вместо номера дня.

# Пример 1
# Ввод
# 6
# 1 2 4 4 6 8
# 3

# Вывод
# 3 5
